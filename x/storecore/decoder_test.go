package storecore

import (
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestDecodeRecord(t *testing.T) {
	tests := map[string]struct {
		data        string
		schema      SchemaTypePair
		expectedOne *DecodedData
	}{
		"static only": {
			data: "0x0000000100000000000000000000000000000002000000000000000000000000000000000000000b0000000008000000000000130000000300000004736f6d6520737472696e67",
			schema: SchemaTypePair{
				Static:           []SchemaType{3, 15},
				Dynamic:          []SchemaType{101, 197},
				StaticDataLength: 20,
			},

			expectedOne: &DecodedData{
				Data: []DataSchemaTypePair{
					{Data: "1", SchemaType: SchemaType(3)},
					{Data: "2", SchemaType: SchemaType(15)},
					{Data: []uint8(`["3","4"]`), SchemaType: SchemaType(101)},
					{Data: "some string", SchemaType: SchemaType(197)},
				},
				Schema: []SchemaType{SchemaType(3), SchemaType(15), SchemaType(101), SchemaType(197)},
			},
		},
		"emtpy record": {
			data: "0x0000000000000000000000000000000000000000000000000000000000000000",
			schema: SchemaTypePair{
				Static:           []SchemaType{},
				Dynamic:          []SchemaType{197, 197},
				StaticDataLength: 0,
			},

			expectedOne: &DecodedData{
				Data: []DataSchemaTypePair{
					{Data: string(""), SchemaType: SchemaType(197)},
					{Data: string(""), SchemaType: SchemaType(197)},
				},
				Schema: []SchemaType{SchemaType(197), SchemaType(197)},
			},
		},
		// TODO: this implementation parses the value, but in MUD it returns one element with 0
		"out of bound array": {
			data: "0x0000000000000000000000000000000000000000000000000400000000000004",
			schema: SchemaTypePair{
				Static:           []SchemaType{},
				Dynamic:          []SchemaType{101},
				StaticDataLength: 0,
			},

			expectedOne: &DecodedData{
				Data: []DataSchemaTypePair{
					{Data: []uint8(`["808464432"]`), SchemaType: SchemaType(101)},
				},
				Schema: []SchemaType{SchemaType(101)},
			},
		},
		"register tables": {
			data: "0x0060030220202000000000000000000000000000000000000000000000000000002001005f000000000000000000000000000000000000000000000000000000006003025f5f5fc4c40000000000000000000000000000000000000000000000" + "000000000000000000000000000000000000022000000000a0000000000002c0" + "00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000077461626c65496400000000000000000000000000000000000000000000000000" + "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000b6669656c644c61796f757400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000096b6579536368656d610000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b76616c7565536368656d610000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012616269456e636f6465644b65794e616d657300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014616269456e636f6465644669656c644e616d6573000000000000000000000000",
			schema: SchemaTypePair{
				Static:           []SchemaType{95, 95, 95},
				Dynamic:          []SchemaType{196, 196},
				StaticDataLength: 192 / 2,
			},
			expectedOne: &DecodedData{
				Data: []DataSchemaTypePair{
					{
						Data:       "0x0060030220202000000000000000000000000000000000000000000000000000",
						SchemaType: SchemaType(95),
					},
					{
						Data:       "0x002001005f000000000000000000000000000000000000000000000000000000",
						SchemaType: SchemaType(95),
					},
					{
						Data:       "0x006003025f5f5fc4c40000000000000000000000000000000000000000000000",
						SchemaType: SchemaType(95),
					},
					{
						Data:       "0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000077461626c65496400000000000000000000000000000000000000000000000000",
						SchemaType: SchemaType(196),
					},
					{
						Data:       "0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000b6669656c644c61796f757400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000096b6579536368656d610000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b76616c7565536368656d610000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012616269456e636f6465644b65794e616d657300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014616269456e636f6465644669656c644e616d6573000000000000000000000000",
						SchemaType: SchemaType(196),
					},
				},
				Schema: []SchemaType{SchemaType(95), SchemaType(95), SchemaType(95), SchemaType(196), SchemaType(196)},
			},
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			actualOne := DecodeRecord(StringToByteArray(test.data), test.schema)
			if diff := cmp.Diff(actualOne, test.expectedOne); diff != "" {
				t.Errorf("static data doesn't match: %v", diff)
			}

		})
	}
}
